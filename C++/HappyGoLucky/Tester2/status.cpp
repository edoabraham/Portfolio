
#include "status.h"

/*
Status::Status() {
	status_.resize(NUM_OF_STATS);
	for(int i = 0; i < NUM_OF_STATS; i++)
		status_[i] - 0;
}

Status::Status(vector<int> status) {
	if(!status.empty() && status.size() == NUM_OF_STATS) {

	}
}

Status::~Status() {

}

void Status::add_status(int index, int value) {
	if(!status_.empty() && index < status_.size())
		status_[index] = value;
}

void Status::add_element(int element) {
	add_status(I_ELEMENT, element);
}

void Status::add_atk(int attack) {
	add_status(I_ATTACK, attack);
}

void Status::add_matk(int magic) {
	add_status(I_MAGIC_ATTACK, magic);
}

void Status::add_hp(int health) {
	add_status(I_HEALTH_POINTS, health);
}

void Status::add_mp(int mana) {
	add_status(I_MANA_POINTS, mana);
}

void Status::add_sp(int stamina) {
	add_status(I_STAMINA_POINTS, stamina);
}

void Status::add_hp_rec(int healthRecovery) {
	add_status(I_HEALTH_RECOVERY, healthRecovery);
}

void Status::add_mp_rec(int manaRecovery) {
	add_status(I_MANA_RECOVERY, manaRecovery);
}

void Status::add_sp_rec(int staminaRecovery) {
	add_status(I_STAMINA_RECOVERY, staminaRecovery);
}

void Status::add_def(int defense) {
	add_status(I_DEFENSE, defense);
}

void Status::add_mdef(int mdefense) {
	add_status(I_MAGIC_DEFENSE, mdefense);
}

void Status::add_mspd(int movement) {
	add_status(I_MOVEMENT_SPEED, movement);
}

void Status::add_aspd(int speed) {
	add_status(I_ATTACK_SPEED, speed);
}

void Status::add_range(int range) {
	add_status(I_RANGE, range);
}


void Status::add_str(int strength) {
	add_status(I_STRENGTH, strength);
}

void Status::add_int(int intelligence) {
	add_status(I_INTELLIGENCE, intelligence);
}

void Status::add_dex(int dexterity) {
	add_status(I_DEXTERITY, dexterity);
}

void Status::add_vit(int vitality) {
	add_status(I_VITALITY, vitality);
}

void Status::add_sta(int stamina) {
	add_status(I_STAMINA, stamina);
}

void Status::add_agi(int agility) {
	add_status(I_AGILITY, agility);
}

void Status::add_luk(int luck) {
	add_status(I_LUCK, luck);
}


void Status::add_crit_rate(int criticalRate) {
	add_status(I_CRITICAL_RATE, criticalRate);
}

void Status::add_crit_dmg_inc(int criticalDamageIncrease) {
	add_status(I_CRITICAL_DAMAGE_INCREASE, criticalDamageIncrease);
}

void Status::add_crit_rate_resist(int criticalResist) {
	add_status(I_CRITICAL_RATE_RESIST, criticalResist);
}

void Status::add_crit_dmg_resist(int criticalDamageResist) {
	add_status(I_CRITICAL_DAMAGE_RESIST, criticalDamageResist);
}



// Output Functions
const int Status::element() const {
	return status_[I_ELEMENT];
}

const int Status::attack() const {
	return status_[I_ATTACK];	
}

const int Status::magic_attack() const {
	return status_[I_MAGIC_ATTACK];
}

const int Status::health_points() const {
	return status_[I_HEALTH_POINTS];
}

const int Status::mana_points() const {
	return status_[I_MANA_POINTS];
}

const int Status::mana_recovery() const {
	return status_[I_MANA_RECOVERY];
}

const int Status::stamina_points() const {
	return status_[I_STAMINA_POINTS];
}

const int Status::stamina_recovery() const {
	return status_[I_STAMINA_RECOVERY];
}

const int Status::defense() const {
	return status_[I_DEFENSE];
}

const int Status::magic_defense() const {
	return status_[I_MAGIC_DEFENSE];
}

const int Status::mspd() const {
	return status_[I_MOVEMENT_SPEED];
}

const int Status::aspd() const {
	return status_[I_ATTACK_SPEED];
}

const int Status::range() const {
	return status_[I_RANGE];
}

*/